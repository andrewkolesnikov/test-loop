#!/usr/bin/env ruby
#
# test-loop - Continuous testing for Ruby with fork/eval
#             https://github.com/sunaku/test-loop#readme
#
####
#
# (the ISC license)
#
# Copyright 2010 Suraj N. Kurapati <sunaku@gmail.com>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#
begin
  def notify message
    puts "test-loop: #{message}"
  end

  notify 'Loading configuration...'
  config_file = File.join(Dir.pwd, '.test-loop')
  load config_file if File.exist? config_file

  (@overhead_file_globs ||= []).
    push('{test,spec}/*{test,spec}_helper.rb').uniq!

  (@reabsorb_file_globs ||= []).
    concat(@overhead_file_globs).
    push(config_file, 'config/*.{rb,yml}').uniq!

  (@source_file_to_test_file_mapping ||= {}).merge!(
    # source files that correspond to test files
    '{lib,app}/**/*.rb' => lambda do |path|
      extn = File.extname(path)
      name = File.basename(path, extn)
      "{test,spec}/**/#{name}_{test,spec}#{extn}"
    end,

    # the actual test files themselves
    '{test,spec}/**/*_{test,spec}.rb' => lambda {|path| path }
  )

  @after_test_execution ||= lambda {|status, ran_at, files|}

  # absorb test execution overhead into master process
  $LOAD_PATH.unshift 'lib' # for non-Rails applications

  notify 'Absorbing overhead...'
  Dir[*@overhead_file_globs].each do |file|
    $LOAD_PATH.insert 1, File.dirname(file)
    require File.basename(file, File.extname(file))
  end

  # continuously watch for and test changed code
  epoch_time = Time.at(0)
  started_at = last_ran_at = Time.now
  trap(:QUIT) { started_at = epoch_time }
  trap(:TSTP) { last_ran_at = epoch_time }

  notify 'Ready for testing!'
  loop do
    # figure out what test files need to be run
    test_files = @source_file_to_test_file_mapping.
    map do |source_file_glob, test_file_glob_mapper|
      Dir[source_file_glob].
      select {|file| File.mtime(file) > last_ran_at }.
      map {|path| Dir[test_file_glob_mapper.call(path)] }
    end.flatten.uniq

    # fork worker process to run the test files
    unless test_files.empty?
      notify 'Running tests...'
      last_ran_at = Time.now
      fork { test_files.each {|file| notify file; load file } }
      Process.wait
      @after_test_execution.call($?, last_ran_at, test_files)
    end

    # reabsorb test execution overhead as necessary
    if Dir[*@reabsorb_file_globs].any? {|file| File.mtime(file) > started_at }
      notify 'Restarting loop...'
      exec $0, *ARGV
    end

    sleep 1
  end
rescue Interrupt
  # user wants to quit the loop
rescue StandardError, LoadError, SyntaxError => error
  puts error.inspect, error.backtrace
  sleep 1 and exec $0, *ARGV
end
