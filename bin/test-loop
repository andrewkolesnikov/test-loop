#!/usr/bin/env ruby
#
# test-loop - Continuous testing for Ruby with fork/eval
#             https://github.com/sunaku/test-loop#readme
#
####
#
# (the ISC license)
#
# Copyright 2010 Suraj N. Kurapati <sunaku@gmail.com>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

require 'rake' # for String#pathmap

def notify message
  puts "test-loop: #{message}"
end

begin
  notify 'Loading configuration...'
  config_file = File.join(Dir.pwd, '.test-loop')
  load config_file if File.exist? config_file

  (@overhead_file_globs ||= []).
    push('{test,spec}/*{test,spec}_helper.rb').uniq!

  (@reabsorb_file_globs ||= []).
    concat(@overhead_file_globs).
    push(config_file, 'config/*.{rb,yml}').uniq!

  (@source_file_to_test_file_mapping ||= {}).merge!(
    '{test,spec}/**/*_{test,spec}.rb' => '%p',
    '{lib,app}/**/*.rb' => '{test,spec}/**/%n_{test,spec}%x'
  )

  @after_test_execution ||= lambda {|status, ran_at, files|}

  # absorb test execution overhead into master process
  $LOAD_PATH.unshift 'lib' # for non-Rails applications

  notify 'Absorbing overhead...'
  Dir[*@overhead_file_globs].each do |file|
    $LOAD_PATH.insert 1, file.pathmap('%d')
    require file.pathmap('%n')
  end

  # continuously watch for and test changed code
  started_at = last_ran_at = Time.now
  never_ran_at = Time.at(0)

  trap :QUIT do
    notify 'Re-executing loop...'
    started_at = never_ran_at
  end

  trap :TSTP do
    notify 'Testing everything...'
    last_ran_at = never_ran_at
  end

  notify 'Ready for testing!'
  loop do
    # figure out what test files need to be run
    test_files = @source_file_to_test_file_mapping.
    map do |source_file_glob, test_file_pathmap|
      Dir[source_file_glob].
      select {|file| File.mtime(file) > last_ran_at }.
      map {|path| Dir[path.pathmap(test_file_pathmap)] }
    end.flatten.uniq

    # fork worker process to run the test files
    unless test_files.empty?
      last_ran_at = Time.now
      fork { test_files.each {|file| notify file; load file } }
      Process.wait
      @after_test_execution.call($?, last_ran_at, test_files)
    end

    # reabsorb test execution overhead as necessary
    if Dir[*@reabsorb_file_globs].any? {|file| File.mtime(file) > started_at }
      notify 'Reabsorbing overhead...'
      exec $0, *ARGV
    end

    sleep 1
  end
rescue StandardError, LoadError => error
  puts error.inspect, error.backtrace
  sleep 1 and exec $0, *ARGV
end
