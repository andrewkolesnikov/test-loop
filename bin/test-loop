#!/usr/bin/env ruby
#
# test-loop - Continuous testing for Ruby with fork/eval
#             https://github.com/sunaku/test-loop#readme
#
####
#
# (the ISC license)
#
# Copyright 2010 Suraj N. Kurapati <sunaku@gmail.com>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

process_invocation_vector = [$0, *ARGV].map! {|s| s.dup }

require 'diff'

begin
  notify = lambda {|message| puts "test-loop: #{message}" }

  notify.call 'Loading configuration...'
  config_file = File.join(Dir.pwd, '.test-loop')
  load config_file if File.exist? config_file

  (@overhead_file_globs ||= []).
    push('{test,spec}/*{test,spec}_helper.rb').uniq!

  (@reabsorb_file_globs ||= []).
    concat(@overhead_file_globs).
    push(config_file, 'config/*.{rb,yml}', 'Gemfile').uniq!

  (@source_file_to_test_file_mapping ||= {}).merge!(
    # source files that correspond to test files
    '{lib,app}/**/*.rb' => lambda do |path|
      extn = File.extname(path)
      name = File.basename(path, extn)
      "{test,spec}/**/#{name}_{test,spec}#{extn}"
    end,

    # the actual test files themselves
    '{test,spec}/**/*_{test,spec}.rb' => lambda {|path| path }
  )

  @test_file_cache = {} # path => readlines

  @test_name_parser ||= lambda do |line|
    case line
    when /^\s*def test_(\w+)/ then $1
    when /^\s*(test|context|should|describe|it)\b (['"])(.*?)\2/ then $3
    end
  end

  @before_each_test ||= lambda do |test_file, test_names|
    unless test_names.empty?
      case File.basename(test_file)

      when /(\b|_)test(\b|_)/ # Minitest
        test_methods = test_names.map {|name| name.gsub(/\W+/, '_').downcase }
        ARGV.push '-n', "/#{test_methods.join('|')}/"

      when /(\b|_)spec(\b|_)/ # RSpec
        ARGV.push '-e', test_names.map {|name| Regexp.quote(name) }.join('|')
      end
    end
  end

  @after_all_tests ||= lambda {|success, ran_at, files, statuses|}

  # absorb test execution overhead into master process
  $LOAD_PATH.unshift 'lib' # for non-Rails applications

  notify.call 'Absorbing overhead...'
  Dir[*@overhead_file_globs].each do |file|
    $LOAD_PATH.insert 1, File.dirname(file)
    require File.basename(file, File.extname(file))
  end

  # continuously watch for and test changed code
  epoch_time = Time.at(0)
  started_at = last_ran_at = Time.now
  trap(:QUIT) { started_at = epoch_time }
  trap(:TSTP) { last_ran_at = epoch_time }

  notify.call 'Ready for testing!'
  loop do
    # figure out what test files need to be run
    test_files = @source_file_to_test_file_mapping.
    map do |source_file_glob, test_file_glob_mapper|
      Dir[source_file_glob].
      select {|file| File.mtime(file) > last_ran_at }.
      map {|path| Dir[test_file_glob_mapper.call(path)] }
    end.flatten.uniq

    # fork worker process to run the test files
    unless test_files.empty?
      notify.call 'Running tests...'
      last_ran_at = Time.now
      test_files.each do |test_file|
        notify.call test_file

        # cache the contents of the test file for diffing below
        new_lines = File.readlines(test_file)
        old_lines = @test_file_cache[test_file] || new_lines
        @test_file_cache[test_file] = new_lines

        fork do
          # determine which test blocks changed inside the test file
          test_names = Diff.new(old_lines, new_lines).diffs.map do |diff|
            line_num = diff[0][1] # wrapped in an extra array for some reason
            catch :found do
              # search backwards from the line that changed up to
              # the first line in the file for test definitions
              line_num.downto(0) do |i|
                if test_name = @test_name_parser.call(new_lines[i])
                  throw :found, test_name
                end
              end
            end
          end.compact.uniq

          @before_each_test.call test_file, test_names
          load test_file
        end
      end

      statuses = Process.waitall.map {|pid, status| status }

      success = true
      test_files.zip(statuses).map do |file, status|
        success &&= test_passed = status.success?
        notify.call "#{test_passed ? 'PASS' : 'FAIL'} #{file}"
      end

      @after_all_tests.call(success, last_ran_at, test_files, statuses)
    end

    # reabsorb test execution overhead as necessary
    if Dir[*@reabsorb_file_globs].any? {|file| File.mtime(file) > started_at }
      notify.call 'Restarting loop...'
      exec(*process_invocation_vector)
    end

    sleep 1
  end

rescue Interrupt
  # user wants to quit the loop

rescue Exception => error
  puts error.inspect, error.backtrace
  sleep 1 and exec(*process_invocation_vector)
end
