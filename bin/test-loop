#!/usr/bin/env ruby
begin
  require 'rake' # for String#pathmap

  def notify message
    puts "test-loop: #{message}"
  end

  notify 'Loading configuration...'
  config_file = File.join(Dir.pwd, 'test-loop.conf')
  load config_file if File.exist? config_file

  (@overhead_file_globs ||= []).
    push('{test,spec}/*{test,spec}_helper.rb').uniq!

  (@reabsorb_file_globs ||= []).
    concat(@overhead_file_globs).
    push(config_file, 'config/*.{rb,yml}').uniq!

  (@source_file_to_test_file_mapping ||= {}).merge!(
    '{test,spec}/**/*_{test,spec}.rb' => '%p',
    '{lib,app}/**/*.rb' => '{test,spec}/**/%n_{test,spec}%x',
  )

  @after_test_execution ||= lambda {|status, ran_at, files|}

  # absorb test execution overhead into master process
  $LOAD_PATH.unshift 'lib' # for non-Rails applications

  notify 'Absorbing overhead...'
  Dir[*@overhead_file_globs].each do |file|
    $LOAD_PATH.insert 1, file.pathmap('%d')
    require file.pathmap('%n')
  end

  # continuously watch for and test changed code
  started_at = last_ran_at = Time.now
  never_ran_at = Time.at(0)

  trap :QUIT do
    notify 'Re-executing loop...'
    started_at = never_ran_at
  end

  trap :TSTP do
    notify 'Testing everything...'
    last_ran_at = never_ran_at
  end

  notify 'Ready for testing!'
  loop do
    # figure out what test files need to be run
    test_files = @source_file_to_test_file_mapping.
    map do |source_file_glob, test_file_pathmap|
      Dir[source_file_glob].
      select {|file| File.mtime(file) > last_ran_at }.
      map {|path| Dir[path.pathmap(test_file_pathmap)] }
    end.flatten.uniq

    # fork worker process to run the test files
    unless test_files.empty?
      last_ran_at = Time.now
      fork { test_files.each {|file| notify file; load file } }
      Process.wait
      @after_test_execution.call($?, last_ran_at, test_files)
    end

    # reabsorb test execution overhead as necessary
    if Dir[*@reabsorb_file_globs].any? {|file| File.mtime(file) > started_at }
      exec $0, *ARGV
    end

    sleep 1
  end
rescue StandardError, LoadError => error
  puts error.inspect, error.backtrace
  sleep 1 and exec $0, *ARGV
end
