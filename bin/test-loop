#!/usr/bin/env ruby
#
# test-loop - Continuous testing for Ruby with fork/eval
#             https://github.com/sunaku/test-loop#readme
#
####
#
# (the ISC license)
#
# Copyright 2010 Suraj N. Kurapati <sunaku@gmail.com>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

process_invocation_vector = [$0, *ARGV].map! {|s| s.dup }

require 'diff'

begin
  notify = lambda {|message| puts "test-loop: #{message}" }

  # load user's configuration and supply default values
  notify.call 'Loading configuration...'
  config_file = File.join(Dir.pwd, '.test-loop')
  config_data = File.read(config_file) if File.exist? config_file
  config = eval(config_data.to_s, TOPLEVEL_BINDING, config_file) || {}

  (config[:overhead_file_globs] ||= []).
    push('{test,spec}/*{test,spec}_helper.rb').uniq!

  (config[:reabsorb_file_globs] ||= []).concat(config[:overhead_file_globs]).
    push(config_file, 'config/*.{rb,yml}', 'Gemfile').uniq!

  (config[:test_file_matchers] ||= {}).merge!(
    # source files that correspond to test files
    '{lib,app}/**/*.rb' => lambda do |path|
      extn = File.extname(path)
      name = File.basename(path, extn)
      "{test,spec}/**/#{name}_{test,spec}#{extn}"
    end,

    # the actual test files themselves
    '{test,spec}/**/*_{test,spec}.rb' => lambda {|path| path }
  )

  config[:test_name_parser] ||= lambda do |line|
    case line
    when /^\s*def\s+test_(\w+)/ then $1
    when /^\s*(test|context|should|describe|it)\b.+?(['"])(.*?)\2/ then $3
    end
  end

  config[:before_each_test] ||= lambda do |test_file, test_names|
    unless test_names.empty?
      test_name_pattern = test_names.map do |name|
        # sanitize string interpolation and non-method-name characters
        name.gsub(/\#\{.*?\}/, ' ').strip.gsub(/\W+/, '.*')
      end.join('|')

      case File.basename(test_file)

      when /(\b|_)test(\b|_)/ # Test::Unit
        ARGV.push '--name', "/#{test_name_pattern}/"

      when /(\b|_)spec(\b|_)/ # RSpec
        ARGV.push '--example', test_name_pattern
      end
    end
  end

  config[:after_all_tests] ||= lambda {|success, ran_at, files, statuses|}

  # absorb test execution overhead into master process
  $LOAD_PATH.unshift 'lib', 'test', 'spec'

  notify.call 'Absorbing overhead...'
  Dir[*config[:overhead_file_globs]].each do |file|
    require File.basename(file, File.extname(file))
  end

  # continuously watch for and test changed code
  test_file_cache = {} # path => readlines
  started_at = last_ran_at = Time.now
  trap(:QUIT) { started_at = Time.at(0) }
  trap(:TSTP) { last_ran_at = Time.at(0); test_file_cache.clear }

  notify.call 'Ready for testing!'
  loop do
    # figure out what test files need to be run
    test_files = config[:test_file_matchers].map do |source_glob, test_matcher|
      Dir[source_glob].select {|file| File.mtime(file) > last_ran_at }.
      map {|path| Dir[test_matcher.call path] }
    end.flatten.uniq

    # fork worker processes to run the test files in parallel
    unless test_files.empty?
      notify.call 'Running tests...'
      last_ran_at = Time.now

      test_files.each do |test_file|
        # cache the contents of the test file for diffing below
        new_lines = File.readlines(test_file)
        old_lines = test_file_cache[test_file] || new_lines
        test_file_cache[test_file] = new_lines

        fork do
          # determine which test blocks have changed inside the test file
          test_names = Diff.new(old_lines, new_lines).diffs.map do |diff|
            catch :found do
              # search backwards from the line that changed up to
              # the first line in the file for test definitions
              diff[0][1].downto(0) do |i| # [[+/-, line number, line value]]
                if test_name = config[:test_name_parser].call(new_lines[i])
                  throw :found, test_name
                end
              end; nil # prevent unsuccessful search from returning an integer
            end
          end.compact.uniq

          config[:before_each_test].call test_file, test_names

          load test_file

          # at this point, the at_exit() hook of the testing framework used by
          # the user's test suite will take care of running all tests defined
          # by the test file loaded above and will also reflect any failures
          # in the worker's exit status
        end
      end

      # wait for worker processes to finish and report results
      statuses = Process.waitall.map {|pid, status| status }

      success = true
      test_files.zip(statuses).each do |file, status|
        success &&= test_passed = status.success?
        notify.call "#{test_passed ? 'PASS' : 'FAIL'} #{file}"
      end
      notify.call "Ran in #{Time.now - last_ran_at} seconds"

      config[:after_all_tests].call success, last_ran_at, test_files, statuses
    end

    # reabsorb test execution overhead as necessary
    if Dir[*config[:reabsorb_file_globs]].any? {|file| File.mtime(file) > started_at }
      notify.call 'Restarting loop...'
      exec(*process_invocation_vector)
    end

    sleep 1
  end

rescue Interrupt
  # user wants to quit the loop; terminate worker processes
  # NOTE: negative PID causes signal to propagate to all child processes
  Process.kill :SIGKILL, -$$

rescue Exception => error
  STDERR.puts error.inspect, error.backtrace
  sleep 1 and exec(*process_invocation_vector)
end
