#!/usr/bin/env ruby
#
# test-loop - Continuous testing for Ruby with fork/eval
#             https://github.com/sunaku/test-loop#readme
#
####
#
# (the ISC license)
#
# Copyright 2010 Suraj N. Kurapati <sunaku@gmail.com>
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#

process_invocation_vector = [$0, *ARGV].map! {|s| s.dup }

begin
  require 'ostruct'
  require 'diff/lcs'

  notify = lambda {|message| puts "test-loop: #{message}" }

  # supply default configuration
  config = $test_loop_config = OpenStruct.new

  config.overhead_file_globs = ['{test,spec}/{test,spec}_helper.rb']

  config.reabsorb_file_globs = config.overhead_file_globs +
    ['config/*.{rb,yml}', 'Gemfile.lock', '.test-loop']

  config.test_file_matchers = {
    # source files that correspond to test files
    '{lib,app}/**/*.rb' => lambda do |path|
      extn = File.extname(path)
      name = File.basename(path, extn)
      "{test,spec}/**/#{name}_{test,spec}#{extn}"
    end,

    # the actual test files themselves
    '{test,spec}/**/*_{test,spec}.rb' => lambda {|path| path }
  }

  config.test_name_parser = lambda do |line|
    case line
    when /^\s*def\s+test_(\w+)/ then $1
    when /^\s*(test|context|should|describe|it)\b.+?(['"])(.*?)\2/ then $3
    end
  end

  config.before_each_test = lambda do |test_file, test_names|
    unless test_names.empty?
      test_name_pattern = test_names.map do |name|
        # sanitize string interpolation and non-method-name characters
        name.gsub(/\#\{.*?\}/, ' ').strip.gsub(/\W+/, '.*')
      end.join('|')

      case File.basename(test_file)
      when /(\b|_)test(\b|_)/ # Test::Unit
        ARGV.push '--name', "/#{test_name_pattern}/"
      when /(\b|_)spec(\b|_)/ # RSpec
        ARGV.push '--example', test_name_pattern
      end
    end
  end

  config.after_all_tests = lambda {|passes, fails, started_at, elapsed_time|}

  # load user's configuration overrides
  if File.exist? config_file = File.join(Dir.pwd, '.test-loop')
    notify.call 'Loading configuration...'
    load config_file
  end

  # absorb test execution overhead into master process
  $LOAD_PATH.unshift 'lib', 'test', 'spec'

  notify.call 'Absorbing overhead...'
  Dir[*config.overhead_file_globs].each do |file|
    require File.basename(file, File.extname(file))
  end

  # continuously watch for and test changed code
  test_file_cache = {} # path => readlines
  started_at = last_ran_at = Time.now
  trap(:QUIT) { started_at = Time.at(0) }
  trap(:TSTP) { last_ran_at = Time.at(0); test_file_cache.clear }

  notify.call 'Ready for testing!'
  loop do
    # figure out what test files need to be run
    test_files = config.test_file_matchers.map do |source_glob, test_matcher|
      Dir[source_glob].select {|file| File.mtime(file) > last_ran_at }.
      map {|path| Dir[test_matcher.call path] }
    end.flatten.uniq

    # fork worker processes to run the test files in parallel
    unless test_files.empty?
      notify.call 'Running tests...'
      last_ran_at = Time.now

      test_files.each do |test_file|
        # cache the contents of the test file for diffing below
        new_lines = File.readlines(test_file)
        old_lines = test_file_cache[test_file] || new_lines
        test_file_cache[test_file] = new_lines

        fork do
          # determine which test blocks have changed inside the test file
          test_names = Diff::LCS.diff(old_lines, new_lines).flatten.map do |change|
            catch :found do
              # search backwards from the line that changed up to
              # the first line in the file for test definitions
              change.position.downto(0) do |i|
                if test_name = config.test_name_parser.call(new_lines[i])
                  throw :found, test_name
                end
              end; nil # prevent unsuccessful search from returning an integer
            end
          end.compact.uniq

          config.before_each_test.call test_file, test_names

          load test_file

          # at this point, the at_exit() hook of the testing framework used by
          # the user's test suite will take care of running all tests defined
          # by the test file loaded above and will also reflect any failures
          # in the worker's exit status
        end
      end

      # wait for worker processes to finish and report results
      test_runs = Process.waitall.map {|pid, status| status }
      elapsed_time = Time.now - last_ran_at

      passes, fails = test_files.zip(test_runs).each do |file, run|
        notify.call "#{run.success? ? 'PASS' : 'FAIL'} #{file}"
      end.partition {|file, run| run.success? }

      notify.call '%d ran, %d passed, %d failed in %0.1f seconds' %
        [test_runs.length, passes.length, fails.length, elapsed_time]

      config.after_all_tests.call passes, fails, last_ran_at, elapsed_time
    end

    # reabsorb test execution overhead as necessary
    if Dir[*config.reabsorb_file_globs].any? {|file| File.mtime(file) > started_at }
      notify.call 'Restarting loop...'
      exec(*process_invocation_vector)
    end

    sleep 1
  end

rescue Interrupt
  # user wants to quit the loop so terminate all worker processes
  Process.kill :SIGKILL, -$$ # negative PID propagates signal to children

rescue Exception => error
  STDERR.puts error.inspect, error.backtrace
  sleep 1 and exec(*process_invocation_vector)
end
